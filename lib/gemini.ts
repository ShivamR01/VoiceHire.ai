// File: lib/gemini.ts
// Updated to fix JSON Array parsing in generateQuestionsFromJD

import { cleanJsonString } from './utils';

// This is the model for standard text generation and feedback.
const TEXT_GEN_MODEL = 'gemini-2.5-flash-preview-09-2025';

// This is the model for multimodal tasks, like transcription.
const MULTIMODAL_MODEL = 'gemini-2.5-flash-preview-09-2025';

// This is the model for high-quality Text-to-Speech.
const TTS_MODEL = 'gemini-2.5-flash-preview-tts';

/**
 * A generic function to generate text from a prompt.
 */
export async function generateText(
  systemPrompt: string,
  userPrompt: string,
  generationConfig?: Record<string, any>
): Promise<string> {
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) throw new Error('GEMINI_API_KEY is not set');

  const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${TEXT_GEN_MODEL}:generateContent?key=${apiKey}`;

  const payload: any = {
    contents: [{ parts: [{ text: userPrompt }] }],
    systemInstruction: {
      parts: [{ text: systemPrompt }],
    },
  };

  if (generationConfig) {
    payload.generationConfig = generationConfig;
  }

  const response = await fetch(apiUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    const errorBody = await response.text();
    console.error('Gemini API Error:', errorBody);
    throw new Error(`API error: ${response.statusText}`);
  }

  const result = await response.json();
  const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

  if (!text) {
    throw new Error('No text generated by AI.');
  }
  return text;
}

/**
 * Transcribes a base64-encoded audio string.
 */
export async function transcribeSpeech(audioBase64: string): Promise<string> {
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) throw new Error('GEMINI_API_KEY is not set');

  const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${MULTIMODAL_MODEL}:generateContent?key=${apiKey}`;

  const payload = {
    contents: [
      {
        parts: [
          {
            text: 'Please transcribe the following audio. Only return the transcribed text.',
          },
          {
            inlineData: {
              mimeType: 'audio/webm',
              data: audioBase64,
            },
          },
        ],
      },
    ],
  };

  let response;
  let lastError;
  for (let i = 0; i < 3; i++) {
    try {
        response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
        });
        if (response.ok) break;
        
        if (response.status >= 500 || response.status === 429) {
             const errorText = await response.text();
             console.warn(`STT Attempt ${i+1} failed: ${response.status} - ${errorText}`);
             await new Promise(res => setTimeout(res, Math.pow(2, i) * 1000));
        } else {
             break; 
        }
    } catch (e) {
        lastError = e;
        console.warn(`STT Network Error Attempt ${i+1}:`, e);
        await new Promise(res => setTimeout(res, Math.pow(2, i) * 1000));
    }
  }

  if (!response || !response.ok) {
    const errorBody = response ? await response.text() : lastError;
    console.error('STT API Error:', errorBody);
    throw new Error(`API error in transcribeSpeech: ${response?.statusText || 'Network Error'}`);
  }

  const result = await response.json();
  const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

  if (!text || text.trim() === "") {
    return ""; 
  }
  
  return text.trim();
}

/**
 * Generates speech from text using the TTS model.
 */
export async function generateSpeech(text: string) {
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) throw new Error('GEMINI_API_KEY is not set');

  const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${TTS_MODEL}:generateContent?key=${apiKey}`;

  const payload = {
    contents: [{ parts: [{ text }] }],
    generationConfig: {
      responseModalities: ['AUDIO'],
      speechConfig: {
        voiceConfig: {
          prebuiltVoiceConfig: { voiceName: 'Kore' }, 
        },
      },
    },
    model: TTS_MODEL,
  };

  const response = await fetch(apiUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    const errorBody = await response.text();
    console.error('TTS API Error Body:', errorBody);
    throw new Error(`API error: ${response.statusText}`);
  }

  const result = await response.json();
  const part = result?.candidates?.[0]?.content?.parts?.[0];
  const audioData = part?.inlineData?.data;
  const mimeType = part?.inlineData?.mimeType;

  if (!audioData || !mimeType || !mimeType.startsWith('audio/')) {
    throw new Error('Invalid TTS response from API.');
  }

  const sampleRateMatch = mimeType.match(/rate=(\d+)/);
  const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 24000;

  return { audioData, sampleRate };
}

/**
 * Generates a structured list of interview questions from a job description.
 */
export async function generateQuestionsFromJD(
  jobDescription: string
): Promise<{ question: string }[]> {
  const systemPrompt = `You are an expert HR recruiter. Generate 5 high-quality interview questions based on the job description.
  Format: JSON Array of objects with a "question" field.
  Example: [{"question": "..."}]`;

  const responseSchema = {
    type: 'ARRAY',
    items: {
      type: 'OBJECT',
      properties: {
        question: {
          type: 'STRING',
        },
      },
      required: ['question'],
    },
  };

  const generationConfig = {
    responseMimeType: 'application/json',
    responseSchema: responseSchema,
  };

  const jsonString = await generateText(
    systemPrompt,
    jobDescription,
    generationConfig
  );

  try {
    // FIX: Implement Array-aware cleaning logic
    // The standard cleanJsonString might break Arrays if it looks for '{' first.
    let cleaned = jsonString.trim();
    
    // Remove markdown fences if present
    cleaned = cleaned.replace(/^```json\s*/, '').replace(/^```\s*/, '').replace(/\s*```$/, '');

    // Find the start of the JSON structure
    const firstSquare = cleaned.indexOf('[');
    const firstCurly = cleaned.indexOf('{');
    
    let startIndex = -1;
    let endIndex = -1;

    // If Array starts before Object (or no Object), treat as Array
    if (firstSquare !== -1 && (firstCurly === -1 || firstSquare < firstCurly)) {
        startIndex = firstSquare;
        endIndex = cleaned.lastIndexOf(']');
    } 
    // Else if Object starts first
    else if (firstCurly !== -1) {
        startIndex = firstCurly;
        endIndex = cleaned.lastIndexOf('}');
    }

    if (startIndex !== -1 && endIndex !== -1) {
        cleaned = cleaned.substring(startIndex, endIndex + 1);
    }
    
    // 2. Parse
    let parsed = JSON.parse(cleaned);

    // 3. Handle Object Wrapping (e.g. { "questions": [...] })
    if (!Array.isArray(parsed) && typeof parsed === 'object' && parsed !== null) {
        const keys = Object.keys(parsed);
        // Find the first key that contains an array
        const arrayKey = keys.find(k => Array.isArray(parsed[k]));
        if (arrayKey) {
            parsed = parsed[arrayKey];
        }
    }

    if (!Array.isArray(parsed)) {
        throw new Error("Parsed JSON is not an array.");
    }

    // 4. Normalize Data Structure
    return parsed.map((item: any) => {
        if (typeof item === 'string') {
            return { question: item };
        }
        if (item && typeof item === 'object' && item.question) {
            return { question: String(item.question) };
        }
        return { question: "Invalid question format generated." };
    });

  } catch (e) {
    console.error("Failed to parse generated questions. Raw:", jsonString);
    throw new Error("Failed to generate valid questions structure.");
  }
}